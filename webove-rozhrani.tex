\chapter{Webové rozhraní}
\label{kap:webove-rozhrani}

\section{Prototyp}

Webové rozhraní, umožňující přístup zájemcům k~nahrávkám a jejich přepisu, byl
od začátku plánovanou součástí projektu. Rozhraní bylo navrženo s~těmito
požadovanými vlastnosmi:

\begin{itemize}
\item{výběr nahrávky ze~seznamu}
\item{poslech nahrávky s~obvyklými ovládacími prvky přehrávače}
\item{zobrazení přepisu nahrávky}
\item{vyznačení právě přehrávaného slova}
\item{možnost provést změnu v~přepisu}
\item{automatické zarovnání přepisu se~zvukem}
\item{případné odmítnutí přepisu, pokud zarovnání selže (přepis neodpovídá
vyřčeným slovům)}
\end{itemize}

První implementace byla založena na přehrávači \textit{jPlayer}, modulu pro
knihovnu \textit{jQuery}, který využívá standard HTML5 s~jeho elementem
\texttt{<audio>} a technologii \textit{Adobe Flash}. Pro~dynamickou odezvu
zobrazených prvků na~změny v~datovém modelu jsem použil knihovnu
\textit{knockout}.

Aplikace měla formu jediné stránky s~rozbalovatelným výběrem nahrávky,
ovládacími prvky přehrávače a třemi řádky přepisu. Při označení části
zobrazeného přepisu se stránka překryla rozhraním pro opravu přepisu, jež zvu
\textit{editačním okénkem}. V~editačním okénku se zobrazilo vstupní pole
(\texttt{<textarea>}) s předvyplněným současným přepisem, ovládací prvky pro
přehrátí odpovídající pasáže, odeslání opraveného přepisu a opuštění editačního
okénka.

Šlo o~prostou statickou HTML stránku s~JavaScriptem. K~audiu se přistupovalo
pomocí externí CDN, zatímco přepisy a API pro~zarovnávání oprav byly
na~zvláštním serveru.

Přepis byl uložen a přenášen ve~formátu \textit{JSONp}\footnote{JSON =
JavaScript Object Notation, JSONp = JSON with Padding}, čili jako \textit{JSON}
obalený v~javascriptové funkci kvůli zamezení problémů s~přístupem napříč
doménami.  Každé slovo s~sebou neslo informaci o~svojí pozici v~nahrávce
s~přesností na~setiny sekundy, výslovnost, zápis, slovníkovou formu, délku ticha
za~slověm, informaci o~tom, zda bylo manuálně přepsáno nebo automaticky
rozpoznáno, a v~případě automaticky rozpoznaných slov \textit{confidence
measure} čili míru jistoty rozpoznání.

Převod ze~zápisu slova do~jeho fonetické podoby se děje na~základě pravidlového
algoritmu z~dílny Doc. Pavla Ircinga po~úpravě od~Mgr.~Nina Peterka, Ph.D. Tento
algoritmus zahrnuje časté výjimky z~českých výslovnostních pravidel, ale
neobsahuje rozsáhlý výslovnostní slovník cizích slov. Karel Makoň navíc nezřídka
hovoří o~osobách, jejichž jména se v~mnoha korpusech neobjeví vůbec.

Nad rámec výše popsaných funkcionalit přibyly další na~základě přání uživatelů a
autorovy potřeby:

\begin{itemize}
\item{indikace, do~jaké míry je která nahrávka přepsána,}
\item{manuální posouvání hranic přepisovaného zvukového úseku,}
\item{úprava zápisu slova s~ponecháním výslovnosti,}
\item{identifikace uživatelů včetně sezení, prohlížeče atp.,}
\item{vyhledávání v~přepisech.}
\end{itemize}

Výslovnost je interně zaznamenána pomocí mezerou oddělených fonémů, z~nichž
každý má reprezentaci z~malých písmen sady ASCII. Taková reprezentace není pro
laické uživatele praktická, proto je součástí aplikace převod do~českého
fonetického zápisu a zpět.

Uživatelé jsou proto instruováni, aby slova s~nestandardní výslovností, na~která
narazí poprvé, přepsali foneticky \textit{(džordž)} a poté, co uspěje
automatické zarovnání, slovu opravil přepis \textit{(George)}.

Tato původní verze posloužila k~přepsání asi 600 tisíc slov a běžela asi 5 let,
než bylo nutné ji nahradit.

\section{Verze 2}

Pro kompletní přepis aplikace se postupně objevilo několik důvodů. Hlavním
z~nich bylo, že původní aplikace mohla jen těžko sloužit pro širokou veřejnost
jako prostředek k~popularizaci nahrávek. Dalším důvodem bylo, že některé kýžené
funkce nebylo možné zprovoznit bez zásadních změn v~provedení. Především šlo
o~ekvalizér, čili frekvenční korekci při poslechu. Akutním důvodem pak byl fakt,
že všechny významné prohlížeče opouštěly podporu Flashe.

Pro novou verzi jsem zvolil technologie React + Redux jako aplikační rámec, Web
Audio API jako platformu pro nakládání se~zvukem a Twitter Bootstrap jako základ
pro vzhled prvků. Zdrojový kód píšu v~ECMAScript~6 a o~kompilaci se stará
webpack.

\subsection{Výběr nahrávky}

První verze obsahovala všudypřítomný rozklikávatelný kategorizovaný seznam
nahrávek. Toto jednoduché řešení mělo jen málo nevýhod. Jedna z~nich byla, že
nešlo použít běžné textové vyhledávání. V~nové verzi je proto použit
dvousloupcový formát, kde vlevo je rozbalovací seznam kategorií a vpravo
lineární seznam nahrávek. Jednotlivé kategorie jsou pak skrolovacími odkazy
do~pravého sloupce a podle stupně skrolování se příslušná kategorie sama
rozbalí (tzv. scrollspy).

Pro lepší přehlednost a v souladu s principem Separation of Concerns je seznam
nahrávek pouze na~úvodní stránce a nikoliv všude.

\subsection{Zobrazení přepisu}

V~první verzi se zobrazovaly vždy tři řádky, kde v~prostředním bylo aktuálně
přehrávané slovo. Výjimkou samozřejmě byly případy, kdy se přehrával začátek
nebo konec nahrávky. Délka řádku odpovídala šířce okna prohlížeče. Takto malý
rozsah zobrazeného textu byl zvolen proto, že aby bylo možné vizuálně odlišit
ručně přepsaná slova od~automaticky rozpoznaných a od~nich ještě slovo aktuálně
přehrávané, muselo být každé slovo obaleno ve~vlastním HTML elementu. Při~větším
množství slov pak bylo rozhraní velice náročné na~výpočetní výkon a znatelně
pomalé, což při synchronním zobrazování přepisu s~přehráváním zvuku není
přijatelné.

Zobrazení jen tří řádků mělo pochopitelně velké nevýhody. Především to, že se
člověk nemohl zorientovat v~širším rámci nahrávky (jejíž průměrná délka je kolem
hodiny) a že opět nebylo možné vyhledávat v~jejím rámci. Výhodou naopak bylo, že
aktuálně přehrávané slovo bylo vždy snadné najít. Nemožnost označit a tedy ani
přepsat příliš dlouhý úsek bylo pro uživatele možná někdy nepříjemné, ale
redukovalo chyby jak v~přepisu, tak v~automatickém zarovnávání.

Zobrazení celého přepisu při zachování plynulosti a grafickém odlišení
automaticky a manuálně přepsaných slov, slova aktuálně přehrávaného a navíc
slova vybraného kliknutím bylo první velkou výzvou pro návrh stránky přehrávání.
První, nezaslouženou pomocí k~tomu byl vývoj výkonu počítačů od~vzniku první
verze, jakož i optimalizace prohlížečů na~rychlost. Množství elementů, které lze
nyní realisticky zobrazit, se znatelně zvýšilo, ačkoliv naivní řešení zabalení
každého slova stále není praktické. Druhým pomocným faktorem je, že manuálně a
automaticky přepsaná slova se většinou vyskytují ve~větších shlucích. Jen
v~málokterých souborech se často střídají manuálně a automaticky přepsané úseky.
To vypovídá o~nevoli uživatelů k~jinému než kompletnímu, lineárnímu přepisu.
% TODO: ref. aktivní učení
Každý shluk manuálně respektive automaticky přepsaných slov stačí tedy zabalit
do~jednoho elementu.

Zvýraznění jednotlivých slov -- aktuálně přehrávaného a vybraného klikem myší --
se realizuje pomocí umístění barevného rámečku pod~zvýrazněné slovo. To lze
provést díky tomu, že prohlížeče nyní umožňují zjistit polohu označeného textu a
označení lze provést automaticky.\footnote{Viz \texttt{getClientRects} a
\texttt{Range} ve~webových standardech.}

\subsection{Web Audio API}

Přechod na~tuto technologii umožnil některé pokročilé funkce, avšak za~relativně
vysokou cenu. Web Audio API je standard pro~pokročilé zpracování zvukového
signálu v~prohlížeči. Základním konceptem je graf procesních uzlů, které mají
vstup a výstup a mohou se libovolně propojovat. K~dispozici jsou zdroje zvuku
jako oscilátory nebo přehrávače streamů, souborů (tag \texttt{<audio>}) a dat
v~paměti (\texttt{AudioBuffer}) a efekty jako zesílení, dynamická komprese,
mixování kanálů.

Velká výhoda Web Audio API oproti elementu \texttt{<audio>} je možnost přesného
časování, až na~jednotlivé samply. Přehrávání výseku odpovídajícího označenému
textu se proto nemusí provádět pomocí velice nepřesného časovače
\texttt{setTimeout}.

Bez~Web Audio API by také nebylo možné provádět frekvenční korekci při poslechu,
čili mít tzv. \textit{ekvalizér}. Ten je zapotřebí, protože některé nahrávky
mají v~určitém frekvenčním pásmu silný šum, jehož odstranění je s~ekvalizérem
snadné a komfort poslechu se tak razantně zvýší.

Další funkcí, kterou Web Audio API umožňuje, je stahování úseků. Označením
přepsaného textu se definuje úsek nahrávky a ten je možné uložit bez~dalšího
síťového přenosu. Tato funkce však vyžaduje, aby nahrávka byla dekódovaná
v~paměti. Vzhledem k~tomu, že nahrávky mají běžně i hodinu a půl, trvá její
stažení a dekódování opravdu dlouho a navíc prohlížeč kvůli tomu spotřebuje přes
gigabyte operační paměti.

Jsou plány na~to, aby Web Audio API umožnila dekódovat jen část
nahrávky,\footnote{github.com/WebAudio/web-audio-api/issues/1305} proto tento
neutěšený stav zatím nechávám být. Případným řešením by mohlo být buď
streamování (\texttt{<audio>} jako zdrojový uzel) a stažení pouze při potřebě
ukládání úseku nebo změna uložení nahrávek nikoliv jeden soubor na jednu pásku,
nýbrž např. po~minutových úsecích.

Díky tomu, že Web Audio API umožňuje přehrávání binárních dat z~proměnné
v~paměti, nabízí se dekódovanou nahrávku uložit na~persistentní úložiště
uživatelova počítače a při opětovné návštěvě stránky data místo stahování odsud
nahrát.

Moderní prohlížeče poskytují několik bran k~úložišti na~místním disku.
Nejtradičnějšími jsou bezesporu \textit{cookies}, které jsou však pro ukládání
objemnějších dat zcela nepoužitelné. Velice slibnou se jeví
\textit{localStorage}, umožňující ukládání párů klíč-hodnota. I zde však
narážíme na~příliš omezující kvóty. Kupříkladu Firefox ji má na 10MB, přičemž
potřeba je asi 1GB. Dalším kandidátem je \textit{File System API}. Tento
standard pro~izolovaný souborový systém k~dispozici webové aplikaci je zcela
ideálním řešením -- dá se zde i explicitně požádat o~konkrétní diskovou kvótu a
uživatel tak má volbu bez nutnosti práce programátora webové aplikace. Kamenem
úrazu je zde však podpora, která se momentálně omezuje pouze na Google Chrome.

Naštěstí existuje ještě standard \textit{IndexedDB API}, který má uspokojivou
podporu a uložení gigabytu dat je s~ním možné, byť ne zaručené. S~využitím
abstrahující knihovny \textit{Dexie} je proto skrz tento standard ukládání
implementováno. Pro uživatele, kteří delší dobu pracují na jedné a téže nahrávce
se tím přináší velká úspora času a přenesených dat.

\section{Rozdělení nahrávek na úseky}

Vzhledem k~tomu, že ani v~roce 2019 není kurzorový přístup ke zvukovým datům
skrze Web Audio API v~dohlednu, a k tomu jak odrazující dopad má nutnost
stahovat a dekódovat celou nahrávku aspoň při jejím prvním načtení, nezbylo mi,
než změnit způsob, jakým jsou nahrávky uloženy.

Nahrávky jsou uloženy v~několika instancích pro různé účely:

\begin{enumerate}
\item{na backendovém serveru ve formátu MFCC pro nucené zarovnávání,}
\item{v~repozitáři LINDAT ve formátu FLAC za účelem archivace a bádání,}
\item{na CDN ve formátu mp3 za účelem přímého stažení uživatelem,}
\item{taktéž na CDN ve formátech OGG/Vorbis a mp3 pro webové rozhraní.}
\end{enumerate}

Pouze poslední jmenovanou instanci je žádoucí ukládat tak, aby každý soubor byl
jen tak velký, aby jeho stažení a dekódování trvalo únosně dlouho. V~ostatních
případech je lépe zachovat uložení, kde jedna nahrávka odpovídající většinou
jedné straně kazety či jednomu průchodu pásky z~kotouč na kotouč. Třetí a čtvrtá
instance však navzdory rozdílnému účelu sdílejí tatáž data. Bylo proto nutné je
duplikovat.

\subsection{Délka segmentů}

Délka úseků, na které nahrávky rozděluji, ovlivňuje, jak dlouho se každý segment
bude stahovat a dekódovat. Čas stahování a dekódování segmentu, který obsahuje
slovo, na němž je kurzor při prvním požadavku o~přehrávání, je roven zpoždění od
uživatelské akce k začátku přehrávání. Podle internetového periodika
UXMovement\cite{foursecondrule}, začíná uživatel po čtyřech sekundách čekání
upouštět od předchozího záměru. Podle článku Nielsen Norman
Group\cite{websiteresponsetimes} je hranice únosnosti 10 sekund.

Pokud budou úseky příliš dlouhé, jejich stahování a dekódování zabere příliš
mnoho času. Na druhou stranu s každým předělem vnášíme do přehrávání bod, kde se
úseky nalepují a může tam vyvstat artefakt. Také s~každým segmentem se pojí
extra HTTP request s~nezanedbatelnou režií.

Jako vhodný kompromis se jeví segmenty o délce 30 - 120 sekund. Velikost
dvouminutového segmentu je v~komprimovaném formátu při mono/24KHz kolem 0.6MB a
na Intel Core2 o 2,5GHz se dekóduje asi 1.6 sekundy.

\subsection{Hledání bodů předělu}

Vhodným výběrem bodů předělu můžeme omezit dopad případných artefaktů
způsobených nepřesným navázáním. Ideálním by bylo dělit nahrávky v~momentech
ticha. Ne vždy jsou momenty ticha každé dvě minuty, proto z momentů ticha
ustupme k~požadavku pauzy v~řeči. Hovořit dvě minuty bez nádechu hraničí
s~nemožností. Potýkáme se tedy s~úlohou nalézt pauzy v~řeči. Jednak je třeba
ujasnit, podle jakého klíče budeme pauzy vybírat, a jednak, jak je budeme přesně
hledat.

Hledat pauzy v~řeči lze různými způsoby. Nejspolehlivější a nejnáročnější je
manuální označování pauz. Pokoušel jsem se o~to sám a dosáhl jsem rychlosti
přibližně čtyřnásobku rychlosti přehrávání, tedy jeden zapsaný bod předělu za
třicet sekund. Dalších asi pět dobrovolných anotátorů se o~tento úkol pokusilo a
došla jim trpělivost po nule až deseti minutách označkovaného materiálu.

Další velice spolehlivou metodou je hledání podle predikovaných pseudofonémů
ticha v~zarovnaném přepisu. Tuto metodu jsem mohl namnoze použít, neboť
k~většině nahrávek mám automatický nebo i manuální přepis.

Tam, kde pořízení přepisu nebo jeho automatické zarovnání selhalo, lze použít
detekci ticha prostou akustickou analýzou. Tato metoda je velice náchylná
k~chybám v~případě nahrávek s~malým poměrem signálu k~šumu, kterých se v~korpusu
Karla Makoně vyskytuje neutěšeně mnoho.
